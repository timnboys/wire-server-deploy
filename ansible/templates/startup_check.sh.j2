#!/bin/bash
#
# startup_check.sh - Enhanced PostgreSQL Startup Safety Check
# Generated by Ansible from tested configuration
# Purpose: Prevent unsafe PostgreSQL startup with graduated bypass system
#
# Exit 0: Allow startup
# Exit 1: Prevent startup
#

set -euo pipefail

# Configuration
PGVERSION="{{ postgresql_version }}"
PGUSER="{{ repmgr_user }}"
PGDATABASE="{{ repmgr_database }}"
LOGFILE="/var/log/postgresql/startup_check.log"
HOSTNAME=$(hostname)

# Cluster node configuration (auto-generated)
readonly CLUSTER_NODES=(
{% for host in groups['postgresql_rw'] + groups['postgresql_ro'] %}
"{{ hostvars[host]['ansible_default_ipv4']['address'] | default(hostvars[host]['ansible_host']) }}"
{% endfor %}
)

# Logging function (fixed to avoid stdout contamination)
log_message() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [startup_check] $1" >> "$LOGFILE"
    echo "$(date '+%Y-%m-%d %H:%M:%S') [startup_check] $1" >&2
}

# Function to get local timeline
get_local_timeline() {
    local timeline_file="/var/lib/postgresql/17/main/pg_control"
    if [[ -f "$timeline_file" ]]; then
        # Use pg_controldata to get timeline
        /usr/lib/postgresql/17/bin/pg_controldata /var/lib/postgresql/17/main | grep "Latest checkpoint's TimeLineID" | awk '{print $4}' 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

# Function to get cluster timeline
get_cluster_timeline() {
    # Try to get timeline from any reachable node
    for host in "${CLUSTER_NODES[@]}"; do
        if timeline=$(psql -h "$host" -U "$PGUSER" -d "$PGDATABASE" -t -q -c "SELECT timeline_id FROM pg_control_checkpoint();" 2>/dev/null); then
            echo "$timeline" | tr -d ' '
            return 0
        fi
    done
    echo "unknown"
}

# Function to check for active primaries in cluster
check_active_primaries() {
    local primary_count=0
    local primary_hosts=""

    for host in "${CLUSTER_NODES[@]}"; do
        if recovery_status=$(psql -h "$host" -U "$PGUSER" -d "$PGDATABASE" -t -q -c "SELECT pg_is_in_recovery();" 2>/dev/null); then
            recovery_status=$(echo "$recovery_status" | tr -d ' ')
            if [[ "$recovery_status" == "f" ]]; then
                ((primary_count++))
                primary_hosts="$primary_hosts $host"
            fi
        fi
    done

    echo "$primary_count:$primary_hosts"
}

# Function to check node status in repmgr metadata (with retry)
check_node_status() {
    local node_name="$1"
    local max_attempts=3
    local attempt=1

    # Query repmgr.nodes table for this node's status
    local query="SELECT active, type FROM repmgr.nodes WHERE node_name = '$node_name';"

    while [[ $attempt -le $max_attempts ]]; do
        log_message "Connection attempt $attempt/$max_attempts"

        # Try to connect to repmgr database on ANY available node
        local result=""
        local connected_host=""
        for host in "${CLUSTER_NODES[@]}"; do
            if result=$(psql -h "$host" -U "$PGUSER" -d "$PGDATABASE" -t -q -c "$query" 2>/dev/null); then
                connected_host="$host"
                break
            fi
        done

        if [[ -n "$result" ]]; then
            # Log success AFTER getting result to avoid contamination
            log_message "Successfully queried metadata from $connected_host"

            # Clean up the result and return it
            echo "$result" | tr -d ' ' | head -1
            return 0
        fi

        log_message "Attempt $attempt failed, retrying in 2 seconds..."
        sleep 2
        ((attempt++))
    done

    log_message "ERROR: Cannot connect to any repmgr metadata database after $max_attempts attempts"
    return 2  # Cannot determine status
}

# Enhanced bypass validation
validate_bypass_safety() {
    local bypass_type="$1"

    case "$bypass_type" in
        "--force-safe")
            log_message "=== SAFE BYPASS VALIDATION ==="

            # Still check fencing status
            local status_result
            if status_result=$(check_node_status "$HOSTNAME"); then
                local active=$(echo "$status_result" | cut -d'|' -f1)
                if [[ "$active" == "f" ]]; then
                    log_message "ERROR: Node is fenced (active=false)"
                    log_message "Safe bypass cannot override fencing"
                    log_message "Use manual unfencing: simple_fence.sh unfence $HOSTNAME"
                    return 1
                fi
            else
                log_message "ERROR: Cannot verify fencing status (metadata unreachable)"
                log_message "FAIL-SAFE: Safe bypass requires metadata connectivity"
                log_message "Use --force-emergency if metadata is unavailable"
                return 1
            fi

            # Check for timeline conflicts
            local local_tl=$(get_local_timeline)
            local cluster_tl=$(get_cluster_timeline)

            if [[ "$local_tl" != "unknown" && "$cluster_tl" != "unknown" && "$local_tl" != "$cluster_tl" ]]; then
                log_message "ERROR: Timeline mismatch detected"
                log_message "Local timeline: $local_tl, Cluster timeline: $cluster_tl"
                log_message "Safe bypass cannot override timeline conflicts"
                log_message "Use --force-timeline for timeline recovery"
                return 1
            fi

            log_message "SAFE BYPASS: All safety checks passed"
            return 0
            ;;

        "--force-timeline")
            log_message "=== TIMELINE BYPASS VALIDATION ==="

            # Check for multiple active primaries
            local primary_info=$(check_active_primaries)
            local primary_count=$(echo "$primary_info" | cut -d':' -f1)
            local primary_hosts=$(echo "$primary_info" | cut -d':' -f2)

            if [[ "$primary_count" -gt 1 ]]; then
                log_message "ERROR: Multiple active primaries detected ($primary_count)"
                log_message "Active primaries on: $primary_hosts"
                log_message "SPLIT-BRAIN RISK: Timeline bypass denied"
                log_message "Use --force-split-brain for split-brain recovery"
                return 1
            fi

            local local_tl=$(get_local_timeline)
            local cluster_tl=$(get_cluster_timeline)
            log_message "Timeline override: Local=$local_tl, Cluster=$cluster_tl"
            log_message "TIMELINE BYPASS: Allowing startup with timeline divergence"
            return 0
            ;;

        "--force-emergency")
            log_message "=== EMERGENCY BYPASS VALIDATION ==="
            log_message "WARNING: Emergency bypass requested"
            log_message "This bypasses most safety checks"

            # Still check for obvious split-brain
            local primary_info=$(check_active_primaries)
            local primary_count=$(echo "$primary_info" | cut -d':' -f1)

            if [[ "$primary_count" -gt 1 ]]; then
                log_message "CRITICAL: Multiple primaries detected during emergency bypass"
                log_message "Continuing anyway due to emergency override"
            fi

            log_message "EMERGENCY BYPASS: Startup allowed"
            return 0
            ;;

        "--force-split-brain")
            log_message "=== SPLIT-BRAIN RECOVERY BYPASS ==="
            log_message "DANGER: Split-brain recovery bypass requested"
            log_message "This is the most dangerous override"

            # Require explicit confirmation
            if [[ ! -f "/tmp/split-brain-recovery-confirmed" ]]; then
                log_message "ERROR: Split-brain recovery requires confirmation"
                log_message "Create confirmation file: touch /tmp/split-brain-recovery-confirmed"
                log_message "Then retry startup"
                return 1
            fi

            log_message "SPLIT-BRAIN BYPASS: Confirmation found, allowing dangerous startup"
            log_message "Remember to remove: /tmp/split-brain-recovery-confirmed"
            return 0
            ;;

        *)
            log_message "ERROR: Unknown bypass type: $bypass_type"
            return 1
            ;;
    esac
}

# Function to check startup safety
check_startup_safety() {
    log_message "=== PostgreSQL Startup Safety Check ==="
    log_message "Node: $HOSTNAME"

    # Check if this is initial cluster setup (no metadata yet)
    if ! check_node_status "$HOSTNAME" >/dev/null 2>&1; then
        log_message "WARNING: Cannot connect to any repmgr metadata database"
        log_message "FAIL-SAFE: Preventing startup when metadata is unreachable"
        log_message "To bypass: Use --force-safe flag or fix database connectivity"
        log_message "DECISION: PREVENT startup (fail-safe mode)"
        return 1
    fi

    # Get node status from metadata
    local status_result
    status_result=$(check_node_status "$HOSTNAME")
    local exit_code=$?

    case $exit_code in
        0)
            # Successfully got status
            local active=$(echo "$status_result" | cut -d'|' -f1)
            local node_type=$(echo "$status_result" | cut -d'|' -f2)

            log_message "Node status: active=$active, type=$node_type"

            if [[ "$active" == "t" || "$active" == "true" ]]; then
                # Additional timeline safety check
                local local_tl=$(get_local_timeline)
                local cluster_tl=$(get_cluster_timeline)

                if [[ "$local_tl" != "unknown" && "$cluster_tl" != "unknown" && "$local_tl" != "$cluster_tl" ]]; then
                    log_message "WARNING: Timeline mismatch detected"
                    log_message "Local timeline: $local_tl, Cluster timeline: $cluster_tl"
                    log_message "DECISION: PREVENT startup (timeline safety)"
                    log_message "Use --force-timeline if timeline recovery needed"
                    return 1
                fi

                log_message "DECISION: ALLOW startup (node is active and timeline safe)"
                return 0
            else
                log_message "DECISION: PREVENT startup (node is fenced/inactive)"
                log_message "To unfence: Use repmgr or run simple_fence.sh manually"
                return 1
            fi
            ;;
        2)
            # Cannot connect to metadata
            log_message "WARNING: Cannot access metadata - safe default"
            log_message "DECISION: PREVENT startup (cannot verify safety)"
            return 1
            ;;
        *)
            # Node not found in metadata
            log_message "WARNING: Node not found in metadata"
            log_message "DECISION: PREVENT startup (unknown node state)"
            return 1
            ;;
    esac
}

# Main execution
main() {
    # Ensure log directory exists
    mkdir -p "$(dirname "$LOGFILE")"

    # Check startup safety
    if check_startup_safety; then
        log_message "Startup check PASSED - PostgreSQL will start"
        exit 0
    else
        log_message "Startup check FAILED - PostgreSQL startup prevented"
        exit 1
    fi
}

# Enhanced bypass handling
case "${1:-}" in
    "--force-safe"|"--force-timeline"|"--force-emergency"|"--force-split-brain")
        mkdir -p "$(dirname "$LOGFILE")"
        log_message "=== BYPASS REQUEST: $1 ==="
        if validate_bypass_safety "$1"; then
            log_message "Bypass validation PASSED - PostgreSQL will start"
            exit 0
        else
            log_message "Bypass validation FAILED - PostgreSQL startup prevented"
            exit 1
        fi
        ;;
    "--force")
        # Legacy support with warning
        mkdir -p "$(dirname "$LOGFILE")"
        log_message "WARNING: Legacy --force bypass detected"
        log_message "Consider using specific bypass: --force-safe, --force-timeline, --force-emergency"
        log_message "EMERGENCY: Forced startup bypass requested"
        log_message "DECISION: ALLOW startup (--force override)"
        exit 0
        ;;
    "")
        # Normal operation
        main "$@"
        ;;
    *)
        echo "Usage: $0 [--force-safe|--force-timeline|--force-emergency|--force-split-brain]"
        echo ""
        echo "Bypass options:"
        echo "  --force-safe      : Safe bypass (validates fencing and timelines)"
        echo "  --force-timeline  : Timeline bypass (allows timeline divergence)"
        echo "  --force-emergency : Emergency bypass (minimal checks)"
        echo "  --force-split-brain : Split-brain recovery (requires confirmation)"
        echo ""
        exit 1
        ;;
esac