---
- name: Deploy PostgreSQL cluster with streaming replication (no installation)
  hosts: postgresql
  become: yes
  gather_facts: yes
  vars:
    postgresql_version: 17
    postgresql_data_dir: /var/lib/postgresql/{{ postgresql_version }}/main
    postgresql_conf_dir: /etc/postgresql/{{ postgresql_version }}/main
    repmgr_user: repmgr
    repmgr_password: "securepassword"
    repmgr_database: repmgr_db
    # Define IPs explicitly or use inventory_hostname
    postgres_nodes:
      postgresql1: "{{ hostvars['postgresql1']['ansible_default_ipv4']['address'] | default(hostvars['postgresql1']['ansible_host'] | default('postgresql1')) }}"
      postgresql2: "{{ hostvars['postgresql2']['ansible_default_ipv4']['address'] | default(hostvars['postgresql2']['ansible_host'] | default('postgresql2')) }}"
      postgresql3: "{{ hostvars['postgresql3']['ansible_default_ipv4']['address'] | default(hostvars['postgresql3']['ansible_host'] | default('postgresql3')) }}"

  tasks:

    # Check replication status to determine if setup is needed
    - name: Check if replica is already configured
      ansible.builtin.stat:
        path: "{{ postgresql_data_dir }}/standby.signal"
      register: replica_configured
      when: inventory_hostname in ["postgresql2", "postgresql3"]

    - name: Check if PostgreSQL is running on replicas
      ansible.builtin.service_facts:
      register: service_status
      when: inventory_hostname in ["postgresql2", "postgresql3"]

    - name: Check replication user exists on primary
      community.postgresql.postgresql_query:
        login_db: postgres
        query: "SELECT 1 FROM pg_roles WHERE rolname = '{{ repmgr_user }}'"
      register: repl_user_exists
      become: yes
      become_user: postgres
      when: inventory_hostname == "postgresql1"
      ignore_errors: yes

    - name: Check replication slots exist on primary
      community.postgresql.postgresql_query:
        login_db: postgres
        query: "SELECT slot_name FROM pg_replication_slots WHERE slot_name IN ('postgresql2', 'postgresql3')"
      register: existing_slots
      become: yes
      become_user: postgres
      when: inventory_hostname == "postgresql1"
      ignore_errors: yes

    - name: Configure pg_hba.conf for all nodes
      ansible.builtin.template:
        src: templates/pg_hba.conf.j2
        dest: "{{ postgresql_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: '0640'
        backup: yes

    - name: Configure primary node PostgreSQL settings
      ansible.builtin.template:
        src: templates/postgresql_primary.conf.j2
        dest: "{{ postgresql_conf_dir }}/postgresql.conf"
        owner: postgres
        group: postgres
        mode: '0640'
        backup: yes
      when: inventory_hostname == "postgresql1"
      register: primary_conf_result

    - name: restart postgresql primary
      ansible.builtin.service:
        name: postgresql
        state: restarted
      become: yes
      when: 
          - inventory_hostname == "postgresql1"
          - primary_conf_result.changed

    - name: Configure replica nodes PostgreSQL settings
      ansible.builtin.template:
        src: templates/postgresql_replica.conf.j2
        dest: "{{ postgresql_conf_dir }}/postgresql.conf"
        owner: postgres
        group: postgres
        mode: '0640'
        backup: yes
      when: inventory_hostname in ["postgresql2", "postgresql3"]
      register: replica_conf_result

    - name: restart postgresql replica
      ansible.builtin.service:
        name: postgresql
        state: restarted
      become: yes
      when: 
        - inventory_hostname in ["postgresql2", "postgresql3"]
        - replica_conf_result is defined
        - replica_conf_result.changed

    # Start primary and configure replication components
    - name: Ensure PostgreSQL service is running on primary
      ansible.builtin.service:
        name: postgresql
        state: started
        enabled: yes
      when: inventory_hostname == "postgresql1"

    - name: Wait for PostgreSQL to be ready on primary
      ansible.builtin.wait_for:
        port: 5432
        host: "{{ postgres_nodes['postgresql1'] }}"
        delay: 5
        timeout: 60
      when: inventory_hostname == "postgresql1"

    - name: Create replication user on primary node 
      community.postgresql.postgresql_user:
        name: "{{ repmgr_user }}"
        password: "{{ repmgr_password }}"
        role_attr_flags: "REPLICATION,LOGIN"
        login_db: postgres
        state: present
      become: yes
      become_user: postgres
      when: 
        - inventory_hostname == "postgresql1"
        - repl_user_exists.failed or (repl_user_exists.query_result | length == 0)

    - name: Create replication slots for replicas on primary 
      community.postgresql.postgresql_slot:
        name: "{{ item }}"
        slot_type: physical
        state: present
        login_db: postgres
      loop:
        - "postgresql2"
        - "postgresql3"
      become: yes
      become_user: postgres
      when: 
        - inventory_hostname == "postgresql1"
        - existing_slots.failed or (item not in (existing_slots.query_result | default([]) | map(attribute='slot_name') | list))

    # Configure replicas only if not already set up
    - name: Stop PostgreSQL on replicas if replication not configured
      ansible.builtin.service:
        name: postgresql
        state: stopped
      when: 
        - inventory_hostname in ["postgresql2", "postgresql3"]
        - not replica_configured.stat.exists

    - name: Clean replica data directories only if replication not configured
      ansible.builtin.file:
        path: "{{ postgresql_data_dir }}"
        state: absent
      when: 
        - inventory_hostname in ["postgresql2", "postgresql3"]
        - not replica_configured.stat.exists
      become: yes

    - name: Run pg_basebackup on replica nodes
      ansible.builtin.command:
        cmd: >
          /usr/bin/pg_basebackup 
          -h {{ postgres_nodes['postgresql1'] }} 
          -U {{ repmgr_user }} 
          -p 5432 
          -D {{ postgresql_data_dir }} 
          -P -R -X stream
      environment:
        PGPASSWORD: "{{ repmgr_password }}"
      when: 
        - inventory_hostname in ["postgresql2", "postgresql3"]
        - not replica_configured.stat.exists
      become: yes
      become_user: postgres

    - name: Create standby.signal file for replicas
      ansible.builtin.file:
        path: "{{ postgresql_data_dir }}/standby.signal"
        state: touch
        owner: postgres
        group: postgres
        mode: '0640'
      when: 
        - inventory_hostname in ["postgresql2", "postgresql3"]
        - not replica_configured.stat.exists

    - name: Start PostgreSQL service on replica nodes
      ansible.builtin.service:
        name: postgresql
        state: started
        enabled: yes
      when: inventory_hostname in ["postgresql2", "postgresql3"]

    - name: Wait for replicas to be ready
      ansible.builtin.wait_for:
        port: 5432
        delay: 10
        timeout: 120
      when: inventory_hostname in ["postgresql2", "postgresql3"]

    # Verification tasks
    - name: Verify streaming replication status on primary
      community.postgresql.postgresql_query:
        login_db: postgres
        query: |
          SELECT 
            client_addr, 
            application_name, 
            state, 
            sync_state,
            pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn)) as lag_size,
            CASE 
              WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) = 0 THEN 'SYNCHRONIZED'
              WHEN pg_wal_lsn_diff(pg_current_wal_lsn(), replay_lsn) < 1024*1024 THEN 'NEAR_SYNC'
              ELSE 'LAGGING'
            END as status
          FROM pg_stat_replication
          WHERE application_name IN ('postgresql2', 'postgresql3')
          ORDER BY application_name;
      register: replication_status
      become: yes
      become_user: postgres
      when: inventory_hostname == "postgresql1"

    - name: Display streaming replication status
      ansible.builtin.debug:
        var: replication_status.query_result
      when: inventory_hostname == "postgresql1"

    - name: Verify replication slots are active
      community.postgresql.postgresql_query:
        login_db: postgres
        query: |
          SELECT 
            slot_name, 
            active, 
            pg_size_pretty(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn)) as slot_lag,
            CASE 
              WHEN active THEN 'ACTIVE'
              ELSE 'INACTIVE - CHECK REPLICA'
            END as slot_status
          FROM pg_replication_slots
          WHERE slot_name IN ('postgresql2', 'postgresql3')
          ORDER BY slot_name;
      register: slot_status
      become: yes
      become_user: postgres
      when: inventory_hostname == "postgresql1"

    - name: Display replication slots status
      ansible.builtin.debug:
        var: slot_status.query_result
      when: inventory_hostname == "postgresql1"

    - name: Check WAL disk usage on primary
      community.postgresql.postgresql_query:
        login_db: postgres
        query: |
          SELECT 
            pg_size_pretty(sum(size)) as total_wal_size,
            count(*) as wal_files,
            CASE 
              WHEN sum(size) > 2147483648 THEN 'WARNING: >2GB WAL usage'
              WHEN sum(size) > 1073741824 THEN 'CAUTION: >1GB WAL usage'
              ELSE 'OK'
            END as wal_status
          FROM pg_ls_waldir();
      register: wal_usage
      become: yes
      become_user: postgres
      when: inventory_hostname == "postgresql1"

    - name: Display WAL usage status
      ansible.builtin.debug:
        var: wal_usage.query_result
      when: inventory_hostname == "postgresql1"


