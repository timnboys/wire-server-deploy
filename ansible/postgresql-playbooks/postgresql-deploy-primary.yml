---
- name: Deploy PostgreSQL Primary node
  hosts: postgresql_rw
  become: yes
  gather_facts: yes
  vars:
    primary_node: "{{ hostvars[(groups.get('postgresql_rw', []) | first) | default('postgresql1')]['ansible_default_ipv4']['address'] | default(hostvars[(groups.get('postgresql_rw', []) | first) | default('postgresql1')]['ansible_host'] | default((groups.get('postgresql_rw', []) | first) | default('postgresql1'))) }}"
    replica_node1: "{{ hostvars[(groups.get('postgresql_ro', []) | first) | default('postgresql2')]['ansible_default_ipv4']['address'] | default(hostvars[(groups.get('postgresql_ro', []) | first) | default('postgresql2')]['ansible_host'] | default((groups.get('postgresql_ro', []) | first) | default('postgresql2'))) }}"
    replica_node2: "{{ hostvars[(groups.get('postgresql_ro', []) | last) | default('postgresql3')]['ansible_default_ipv4']['address'] | default(hostvars[(groups.get('postgresql_ro', []) | last) | default('postgresql3')]['ansible_host'] | default((groups.get('postgresql_ro', []) | last) | default('postgresql3'))) }}"

  tasks:
    # Base PostgreSQL configuration (required for both legacy and repmgr)
    - name: Configure pg_hba.conf
      ansible.builtin.template:
        src: ../templates/pg_hba.conf.j2
        dest: "{{ postgresql_conf_dir }}/pg_hba.conf"
        owner: postgres
        group: postgres
        mode: "0640"
        backup: yes

    - name: Configure primary node PostgreSQL settings
      ansible.builtin.template:
        src: ../templates/postgresql_primary.conf.j2
        dest: "{{ postgresql_conf_dir }}/postgresql.conf"
        owner: postgres
        group: postgres
        mode: "0640"
        backup: yes
      register: primary_conf_result

    # Legacy replication setup (only when repmgr is disabled)
    - name: Legacy replication setup
      block:
        - name: Check legacy replication user exists
          community.postgresql.postgresql_query:
            login_db: postgres
            query: "SELECT 1 FROM pg_roles WHERE rolname = '{{ repsvc_user }}'"
          register: legacy_repl_user_exists
          become_user: postgres
          ignore_errors: yes

        - name: Check legacy replication slots exist
          community.postgresql.postgresql_query:
            login_db: postgres
            query: "SELECT slot_name FROM pg_replication_slots WHERE slot_name IN ('postgresql2', 'postgresql3')"
          register: legacy_existing_slots
          become_user: postgres
          ignore_errors: yes

        - name: Create legacy replication user
          community.postgresql.postgresql_user:
            name: "{{ repsvc_user }}"
            password: "{{ repsvc_password }}"
            role_attr_flags: "REPLICATION,LOGIN"
            login_db: postgres
            state: present
          become_user: postgres
          when:
            - legacy_repl_user_exists.failed or (legacy_repl_user_exists.query_result | length == 0)

        - name: Create legacy replication slots for replicas
          community.postgresql.postgresql_slot:
            name: "{{ item }}"
            slot_type: physical
            state: present
            login_db: postgres
          loop:
            - "postgresql2"
            - "postgresql3"
          become_user: postgres
          when:
            - legacy_existing_slots.failed or (item not in (legacy_existing_slots.query_result | default([]) | map(attribute='slot_name') | list))

      when: not (repmgr_enabled | default(false))

    # repmgr setup (only when repmgr is enabled)
    - name: repmgr High Availability setup
      block:
        - name: Check if repmgr user exists
          community.postgresql.postgresql_query:
            login_db: postgres
            query: "SELECT 1 FROM pg_roles WHERE rolname = '{{ repmgr_user }}'"
          register: repmgr_user_exists
          become_user: postgres
          ignore_errors: yes

        - name: Check if repmgr database exists
          community.postgresql.postgresql_query:
            login_db: postgres
            query: "SELECT 1 FROM pg_database WHERE datname = '{{ repmgr_database }}'"
          register: repmgr_db_exists
          become_user: postgres
          ignore_errors: yes

        - name: Check if repmgr extension exists
          community.postgresql.postgresql_query:
            login_db: "{{ repmgr_database }}"
            login_user: "{{ repmgr_user }}"
            login_password: "{{ repmgr_password }}"
            query: "SELECT 1 FROM pg_extension WHERE extname = 'repmgr'"
          register: repmgr_extension_exists
          become_user: postgres
          ignore_errors: yes

        - name: Create repmgr user
          community.postgresql.postgresql_user:
            name: "{{ repmgr_user }}"
            password: "{{ repmgr_password }}"
            role_attr_flags: SUPERUSER,REPLICATION
            login_db: postgres
            state: present
          become_user: postgres
          when:
            - repmgr_user_exists.failed or (repmgr_user_exists.query_result | length == 0)

        - name: Create repmgr database
          community.postgresql.postgresql_db:
            name: "{{ repmgr_database }}"
            owner: "{{ repmgr_user }}"
            state: present
          become_user: postgres
          when:
            - repmgr_db_exists.failed or (repmgr_db_exists.query_result | length == 0)

        - name: Create .pgpass file for postgres user
          ansible.builtin.template:
            src: ../templates/pgpass.j2
            dest: "/var/lib/postgresql/.pgpass"
            owner: postgres
            group: postgres
            mode: "0600"

        - name: Deploy repmgr configuration
          ansible.builtin.template:
            src: ../templates/repmgr.conf.j2
            dest: "/etc/repmgr/{{ postgresql_version }}/repmgr.conf"
            owner: postgres
            group: postgres
            mode: "0644"

        - name: Deploy fencing and safety scripts
          ansible.builtin.template:
            src: "{{ item.src }}"
            dest: "{{ item.dest }}"
            owner: postgres
            group: postgres
            mode: "0755"
          loop:
            - {
                src: "../templates/simple_fence.sh.j2",
                dest: "/opt/repmgr/scripts/simple_fence.sh",
              }
            - {
                src: "../templates/startup_check.sh.j2",
                dest: "/opt/repmgr/scripts/startup_check.sh",
              }

      when: repmgr_enabled | default(false)

    # Restart PostgreSQL after all configuration changes
    - name: Restart PostgreSQL primary after configuration
      ansible.builtin.service:
        name: postgresql
        state: restarted
      when:
        - primary_conf_result.changed or repmgr_enabled | default(false)

    - name: Ensure PostgreSQL service is running
      ansible.builtin.service:
        name: postgresql
        state: started
        enabled: yes

    - name: Wait for PostgreSQL to be ready
      ansible.builtin.wait_for:
        port: 5432
        host: "{{ primary_node }}"
        delay: 5
        timeout: 60

    # Post-startup repmgr setup (requires PostgreSQL to be running)
    - name: Complete repmgr primary setup
      block:
        - name: Create repmgr extension in database
          community.postgresql.postgresql_ext:
            name: repmgr
            db: "{{ repmgr_database }}"
            login_user: "{{ repmgr_user }}"
            login_password: "{{ repmgr_password }}"
            state: present
          become_user: postgres
          when:
            - repmgr_extension_exists.failed or (repmgr_extension_exists.query_result | length == 0)

        - name: Create replication slots for replica nodes (repmgr)
          community.postgresql.postgresql_slot:
            name: "{{ item }}"
            slot_type: physical
            state: present
            login_db: postgres
            login_user: "{{ repmgr_user }}"
            login_password: "{{ repmgr_password }}"
          loop: "{{ groups['postgresql_ro'] }}"
          become_user: postgres
          ignore_errors: yes # Slots may be created automatically by repmgr

        - name: Check if primary is already registered with repmgr
          ansible.builtin.command:
            cmd: sudo -u postgres repmgr -f /etc/repmgr/{{ postgresql_version }}/repmgr.conf node status
          register: repmgr_node_status
          failed_when: false
          changed_when: false

        - name: Register primary node with repmgr
          ansible.builtin.command:
            cmd: sudo -u postgres repmgr -f /etc/repmgr/{{ postgresql_version }}/repmgr.conf primary register
          when:
            - repmgr_node_status.rc != 0 # Only register if not already registered
          register: repmgr_primary_register
          failed_when:
            - repmgr_primary_register.rc != 0
            - "'already registered' not in repmgr_primary_register.stderr"

        - name: Display primary registration result
          ansible.builtin.debug:
            msg: "{{ repmgr_primary_register.stdout_lines | default(['Primary already registered']) }}"

        - name: Verify repmgr primary registration
          ansible.builtin.command:
            cmd: sudo -u postgres repmgr -f /etc/repmgr/{{ postgresql_version }}/repmgr.conf cluster show
          register: cluster_verification
          changed_when: false

        - name: Display initial cluster status
          ansible.builtin.debug:
            msg: "{{ cluster_verification.stdout_lines }}"

        - name: Verify primary node connectivity
          ansible.builtin.command:
            cmd: sudo -u postgres psql -d {{ repmgr_database }} -c "SELECT node_name, active, node_status FROM repmgr.nodes WHERE type = 'primary'"
          register: primary_verification
          changed_when: false

        - name: Display primary node verification
          ansible.builtin.debug:
            msg: "Primary node status: {{ primary_verification.stdout_lines }}"

      when: repmgr_enabled | default(false)
